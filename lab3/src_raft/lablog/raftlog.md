

一个节点可以处于三种状态的一种：Followers、Candidate、Leader。

1. Leader Election

所有节点以Followers状态启动，如果Followers没有听到Leader的消息，那么它可以成为Candidate。

然后Candidate会请求其他节点投票，其他节点回复投票，如果Candidate从大多数节点获取选票，则称为Leader

现在对所有系统的更改都通过领导者，每个信息（更改）都会成为条目添加到节点的日志中。

2. 日志复制
   1. 客户端仅通过Leader与集群进行交互，比如发送了一个`SET 5`的命令，Leader是不能立即提交的。
   2. 要提交这个条目，需要将这个命令复制到其他跟随者节点，然后Leader等待直到大多数节点写入了这个条目，此时Leader才能提交。
   3. 然后Leader通知跟随者该条目已提交，使跟随者的条目也提交。

两个超时：

1. 选举超时。追随者在成为候选人之前等待的时间，当选举超时后，追随者成为候选人并开始新的选取周期。（150ms - 300ms）

## 投票规则

1. 候选人的日志信息至少要和自己一样新，如果候选人的日志信息滞后于某一个跟随者，那么此跟随者会拒绝投票，因为自己有更新的日志记录。
2. 跟随着节点会比较候选人和自己的日志，以确定哪个更新：
   1. 比较最后一条日志的任期，任期大的日志更新；
   2. 如果相同，则比较最后一条日志的索引，索引大的新。

## 2023-05-21

完成了选举过程的一些函数，剩下flower接受heartbeat如何处理没写。

当客户端向某一个固定的机子发送请求的时候，可以遍历整个集群，然后找到leader，并将信息发送过去。

## 2023-05-22

不考虑集群中的机子会crash

### 如何处理Leader Node的信息

维护一个变量`currentLeaderid`，然后Leader节点通过在心跳信息里面传递自己的nodeid来更新这个变量。

由于心跳信息会比较频繁，所以这个变量会更新的比较快。

### 日志复制过程中 Leader是将整个日志都发送给Follower吗？

并不是，整个发送的话代价比较大，选择遍历日志将日志逐个发送给Follower。

